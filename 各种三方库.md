## C++
### folly
folly 是 Facebook（现 Meta）开源的一款功能强大的 C++ 库。
地址：https://github.com/facebook/folly

folly（全称 Facebook Open-source Library）是 Meta 为大规模高性能 C++ 应用开发打造的基础库，是一套综合性的 C++ 工具集，填补了 C++ 标准库在高性能场景下的不足，广泛用于 Meta 内部的服务端、移动端等核心系统。

folly 包含了大量实用且高性能的组件，核心模块包括：
- **基础数据结构**：如高性能的字符串处理（fbstring）、动态数组（dynamic）、无锁队列（MPMCQueue）等；
- **并发与线程**：轻量级线程（fibers）、原子操作、线程池、同步原语（如SharedMutex）；
- **网络与 IO**：异步 IO、HTTP 客户端 / 服务端、字节流处理；
- **内存管理**：高效的内存分配器（jemalloc封装）、对象池；
- **工具类**：日志、异常处理、配置解析、性能监控等。

该库：
- 适配 C++11 及以上标准，对高性能、低延迟、高并发场景做了极致优化；
- 依赖较少（主要依赖系统库和 jemalloc），但对编译环境要求较高（需 GCC 7+、Clang 6 + 等）；
- 主要用于服务端开发，不推荐在移动端等资源受限场景直接使用（体积较大）。


### DLPack
DLPack 是一个用于在不同深度学习框架之间共享张量内存的开放标准，是一份“张量该长什么样、怎么被别人安全接管”的协议。
DLPack 实现了**零拷贝**共享张量数据。

DLPack 定义了一个极小但足够的信息集合：
- 数据指针（data pointer）
- shape / ndim
- strides
- dtype（float32、int64…）
- device（CPU / CUDA / ROCm / …）
- 谁负责释放内存（ownership）
这些信息打包成一个结构体，叫：
```cpp
DLManagedTensor
```
“Managed”的意思很重要：
它自带析构协议，明确谁最后负责 free 内存，避免 double free 或泄漏。

## python
### decorator
该库的主要价值是简化装饰器的编写。
解决原生 Python 装饰器在保留函数元信息（如名称、文档字符串）、处理参数、嵌套装饰等场景下的痛点

安装：
```python 
pip install decorator
```
示例：
```python
# 示例 1
# 原生写法 vs decorator 库写法对比：
import time
from functools import wraps

def time_raw(fun):
    @wraps(fun) # # 必须加，否则 func.__name__ 会变成 wrapper
    def wrapper(*args, **kwargs):
        start = time.time()
        result = fun(*args, **kwargs)
        end = time.time()
        print(f"{fun.__name__} 执行耗时：{end - start::4f} 秒")
        return result
    return wrapper

# 使用 decorator 库的写法
import time 
from decorator import decorator

@decorator
def time_deco(fun, *args, **kwargs):
    start = time.time()
    result = fun(*args, **kwargs)
    end = time.time()
    print(f"{fun.__name__} 执行耗时：{end - start::4f} 秒")
    return result

# 测试装饰器
print("=======示例1:测试简单装饰器=======")
@time_deco
def test_fun(n):
    """测试函数：计算 1 到 n 的和"""
    return sum(range(n))

# 验证元信息是否保留
print(test_fun.__name__)
print(test_fun.__doc__)
test_fun(1000)
print("=======示例1:测试结束=======")


# 示例2：带参数的装饰器
def time_witf_args(enable=True):
    @decorator
    def wrapper(func, *args, **kwargs):
        if not enable:
            return func(*args, **kwargs)
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{fun.__name__} 执行耗时：{end - start::4f} 秒")
        return result
    return wrapper

print("=======示例2:测试带参数的装饰器=======")

@time_witf_args
def test_func2(n):
    return sum(range(n))

test_func2(1000)
print("=======示例2:测试结束=======")

# 示例3:decorator 库的 FunctionMaker TODO
# 示例4:异步装饰器 TODO
```