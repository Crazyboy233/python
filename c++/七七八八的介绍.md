### 关键字介绍
#### explicit
主要作用是**禁止构造函数的隐式类型转换**。
`explicit` 只能修饰**单参数的构造函数**（C++11 后也支持修饰多参数但带默认值的构造函数），它的核心作用是：
- 不加 `explicit` 时，单参数构造函数会成为 “转换构造函数”，允许编译器自动进行隐式类型转换。
- 加上 `explicit` 后，必须通过**显式调用**构造函数才能创建对象，禁止隐式转换。

### std::function
C++11 引入。是一个通用，多态的函数包装器。可以封装普通函数，Lambda表达式，函数对象，类成员函数等几乎所有可调用对象。是实现回调，函数式编程的核心工具。
`std::function` 本质是一个模板类，定义在 `<functional>` 中，主要价值：
- **统一可调用对象的类型**：不同类型的可调用对象（比如普通函数和 Lambda）可以被包装成相同的 `std::function` 类型，便于统一管理和传递；
- **类型安全**：编译期检查参数和返回值类型是否匹配，避免运行时类型错误；
- **支持空状态**：可以赋值为 `nullptr`，表示无可用的可调用对象。

下面是常见的封装场景。
重要：场景4:
```c++
#include <iostream>
#include <functional>  // 必须包含此头文件
#include <string>

// 1. 普通函数
std::string greet(const std::string& name) {
    return "Hello, " + name;
}

// 2. 函数对象（仿函数）
struct Add {
    int operator()(int a, int b) const {
        return a + b;
    }
};

// 3. 类成员函数
class Calculator {
public:
    int multiply(int a, int b) const {
        return a * b;
    }
};

int main() {
    // ========== 场景1：封装普通函数 ==========
    std::function<std::string(const std::string&)> func1 = greet;
    std::cout << func1("Tom") << std::endl;  // 输出：Hello, Tom

    // ========== 场景2：封装Lambda表达式 ==========
    std::function<int(int, int)> func2 = [](int a, int b) {
        return a - b;
    };
    std::cout << func2(10, 3) << std::endl;  // 输出：7

    // ========== 场景3：封装函数对象 ==========
    std::function<int(int, int)> func3 = Add();
    std::cout << func3(4, 5) << std::endl;  // 输出：9

    // ========== 场景4：封装类成员函数 ==========
    // 注意：成员函数需要绑定对象（或指针），第一个参数是对象/指针
    Calculator calc;
    std::function<int(const Calculator&, int, int)> func4 = &Calculator::multiply;
    std::cout << func4(calc, 6, 7) << std::endl;  // 输出：42

    // 也可以用std::bind绑定对象，简化调用
    auto func5 = std::bind(&Calculator::multiply, &calc, std::placeholders::_1, std::placeholders::_2);
    std::cout << func5(8, 9) << std::endl;  // 输出：72

    // ========== 场景5：空状态与判空 ==========
    std::function<void()> func6;
    if (!func6) {  // 判空
        std::cout << "func6 is empty" << std::endl;  // 输出：func6 is empty
    }
    func6 = []() { std::cout << "func6 is now valid" << std::endl; };
    func6();  // 输出：func6 is now valid

    return 0;
}
```
关键解释：
- **模板参数格式**：`std::function<返回值类型(参数类型1, 参数类型2, ...)>`，比如 `std::function<float(int, int)>` 表示 “接收两个 int、返回 float 的可调用对象”。
- **类成员函数的特殊处理**：
  - 类成员函数本质上隐含第一个参数 this 指针，因此封装时需要把对象 / 指针纳入参数列表，或用 std::bind 绑定对象。
  - 静态成员函数无需绑定对象，用法和普通函数一致。
- **性能注意事项**：
  - std::function 是多态包装器，有轻微的性能开销（主要是间接调用），但在绝大多数场景下可忽略；
  - 如果对性能极致敏感（如 folly 的高性能场景），可优先使用函数指针或模板，但 std::function 的灵活性远胜前者。