### 关键字介绍
#### explicit
主要作用是**禁止构造函数的隐式类型转换**。
`explicit` 只能修饰**单参数的构造函数**（C++11 后也支持修饰多参数但带默认值的构造函数），它的核心作用是：
- 不加 `explicit` 时，单参数构造函数会成为 “转换构造函数”，允许编译器自动进行隐式类型转换。
- 加上 `explicit` 后，必须通过**显式调用**构造函数才能创建对象，禁止隐式转换。

#### mutable
主要作用是**让类的成员变量在 `const` 成员函数中可修改**。
注：
- **只能修饰非静态成员变量**：`mutable`不能修饰全局变量，静态变量，函数或者参数。
- **不能修饰 `const/volatile` 变量**：比如 `mutable const int a;` 是非法的。
- **仅影响 `const` 成员函数**：非 `const` 成员函数中，`mutable` 没有特殊作用(变量本来就可以修改)。
- **遵守“逻辑常量性”**：`mutable` 应只用于修改 “不影响对象对外表现” 的辅助变量，不要滥用它修改核心数据(否则违背 `const` 的设计初衷)。

下面介绍一个基础用法(修改辅助变量)：
```c++
//最典型的场景是“缓存计算结果”：对象的核心数据不变，但为了性能缓存计算结果，缓存变量可以用`mutable`修饰。
#include <iostream>
#include <string>

class Person {
private:
    std::string name;
    // 辅助变量：缓存姓名的哈希值（修改它不影响对象核心状态）
    mutable int name_hash = 0;
    // 辅助变量：记录访问次数
    mutable int access_count = 0;

public:
    Person(const std::string& n) : name(n) {}

    // const 成员函数：本意是“只读姓名，不修改对象”
    std::string getName() const {
        access_count++;  // 允许修改 mutable 变量
        return name;
    }

    // const 成员函数：计算姓名哈希（缓存结果避免重复计算）
    int getNameHash() const {
        if (name_hash == 0) {
            // 即使在 const 函数中，也能修改 mutable 的 name_hash
            for (char c : name) {
                name_hash += c;
            }
        }
        return name_hash;
    }

    // 查看访问次数（辅助信息）
    int getAccessCount() const {
        return access_count;
    }
};

int main() {
    const Person p("Alice");  // 定义 const 对象（完全只读）
    std::cout << p.getName() << std::endl;       // 输出：Alice
    std::cout << p.getNameHash() << std::endl;  // 输出：Alice 的 ASCII 总和
    std::cout << p.getAccessCount() << std::endl;// 输出：2（两次调用 const 函数）
    return 0;
}
```

### std::function
C++11 引入。是一个通用，多态的函数包装器。可以封装普通函数，Lambda表达式，函数对象，类成员函数等几乎所有可调用对象。是实现回调，函数式编程的核心工具。
`std::function` 本质是一个模板类，定义在 `<functional>` 中，主要价值：
- **统一可调用对象的类型**：不同类型的可调用对象（比如普通函数和 Lambda）可以被包装成相同的 `std::function` 类型，便于统一管理和传递；
- **类型安全**：编译期检查参数和返回值类型是否匹配，避免运行时类型错误；
- **支持空状态**：可以赋值为 `nullptr`，表示无可用的可调用对象。

下面是常见的封装场景。
重要：场景4:
```c++
#include <iostream>
#include <functional>  // 必须包含此头文件
#include <string>

// 1. 普通函数
std::string greet(const std::string& name) {
    return "Hello, " + name;
}

// 2. 函数对象（仿函数）
struct Add {
    int operator()(int a, int b) const {
        return a + b;
    }
};

// 3. 类成员函数
class Calculator {
public:
    int multiply(int a, int b) const {
        return a * b;
    }
};

int main() {
    // ========== 场景1：封装普通函数 ==========
    std::function<std::string(const std::string&)> func1 = greet;
    std::cout << func1("Tom") << std::endl;  // 输出：Hello, Tom

    // ========== 场景2：封装Lambda表达式 ==========
    std::function<int(int, int)> func2 = [](int a, int b) {
        return a - b;
    };
    std::cout << func2(10, 3) << std::endl;  // 输出：7

    // ========== 场景3：封装函数对象 ==========
    std::function<int(int, int)> func3 = Add();
    std::cout << func3(4, 5) << std::endl;  // 输出：9

    // ========== 场景4：封装类成员函数 ==========
    // 注意：成员函数需要绑定对象（或指针），第一个参数是对象/指针
    Calculator calc;
    std::function<int(const Calculator&, int, int)> func4 = &Calculator::multiply;
    std::cout << func4(calc, 6, 7) << std::endl;  // 输出：42

    // 也可以用std::bind绑定对象，简化调用
    auto func5 = std::bind(&Calculator::multiply, &calc, std::placeholders::_1, std::placeholders::_2);
    std::cout << func5(8, 9) << std::endl;  // 输出：72

    // ========== 场景5：空状态与判空 ==========
    std::function<void()> func6;
    if (!func6) {  // 判空
        std::cout << "func6 is empty" << std::endl;  // 输出：func6 is empty
    }
    func6 = []() { std::cout << "func6 is now valid" << std::endl; };
    func6();  // 输出：func6 is now valid

    return 0;
}
```
关键解释：
- **模板参数格式**：`std::function<返回值类型(参数类型1, 参数类型2, ...)>`，比如 `std::function<float(int, int)>` 表示 “接收两个 int、返回 float 的可调用对象”。
- **类成员函数的特殊处理**：
  - 类成员函数本质上隐含第一个参数 this 指针，因此封装时需要把对象 / 指针纳入参数列表，或用 std::bind 绑定对象。
  - 静态成员函数无需绑定对象，用法和普通函数一致。
- **性能注意事项**：
  - std::function 是多态包装器，有轻微的性能开销（主要是间接调用），但在绝大多数场景下可忽略；
  - 如果对性能极致敏感（如 folly 的高性能场景），可优先使用函数指针或模板，但 std::function 的灵活性远胜前者。